description: "12.12 program_opencl\nFilter video using an OpenCL program.\n\n\nThe\
  \ program_opencl filter also supports the framesync options.\n\nThe program source\
  \ file must contain a kernel function with the given name,\nwhich will be run once\
  \ for each plane of the output.  Each run on a plane\ngets enqueued as a separate\
  \ 2D global NDRange with one work-item for each\npixel to be generated.  The global\
  \ ID offset for each work-item is therefore\nthe coordinates of a pixel in the destination\
  \ image.\n\nThe kernel function needs to take the following arguments:\n\n Destination\
  \ image, __write_only image2d_t.\n\nThis image will become the output; the kernel\
  \ should write all of it.\n Frame index, unsigned int.\n\nThis is a counter starting\
  \ from zero and increasing by one for each frame.\n Source images, __read_only image2d_t.\n\
  \nThese are the most recent images on each input.  The kernel may read from\nthem\
  \ to generate the output, but they can\u2019t be written to.\n\nExample programs:\n\
  \n\n Copy the input to the output (output must be the same size as the input).\n\
  __kernel void copy(__write_only image2d_t destination,\n                   unsigned\
  \ int index,\n                   __read_only  image2d_t source)\n{\n    const sampler_t\
  \ sampler = CLK_NORMALIZED_COORDS_FALSE;\n\n    int2 location = (int2)(get_global_id(0),\
  \ get_global_id(1));\n\n    float4 value = read_imagef(source, sampler, location);\n\
  \n    write_imagef(destination, location, value);\n}\n\n Apply a simple transformation,\
  \ rotating the input by an amount increasing\nwith the index counter.  Pixel values\
  \ are linearly interpolated by the\nsampler, and the output need not have the same\
  \ dimensions as the input.\n__kernel void rotate_image(__write_only image2d_t dst,\n\
  \                           unsigned int index,\n                           __read_only\
  \  image2d_t src)\n{\n    const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE\
  \ |\n                               CLK_FILTER_LINEAR);\n\n    float angle = (float)index\
  \ / 100.0f;\n\n    float2 dst_dim = convert_float2(get_image_dim(dst));\n    float2\
  \ src_dim = convert_float2(get_image_dim(src));\n\n    float2 dst_cen = dst_dim\
  \ / 2.0f;\n    float2 src_cen = src_dim / 2.0f;\n\n    int2   dst_loc = (int2)(get_global_id(0),\
  \ get_global_id(1));\n\n    float2 dst_pos = convert_float2(dst_loc) - dst_cen;\n\
  \    float2 src_pos = {\n        cos(angle) * dst_pos.x - sin(angle) * dst_pos.y,\n\
  \        sin(angle) * dst_pos.x + cos(angle) * dst_pos.y\n    };\n    src_pos =\
  \ src_pos * src_dim / dst_dim;\n\n    float2 src_loc = src_pos + src_cen;\n\n  \
  \  if (src_loc.x < 0.0f      || src_loc.y < 0.0f ||\n        src_loc.x > src_dim.x\
  \ || src_loc.y > src_dim.y)\n        write_imagef(dst, dst_loc, 0.5f);\n    else\n\
  \        write_imagef(dst, dst_loc, read_imagef(src, sampler, src_loc));\n}\n\n\
  \ Blend two inputs together, with the amount of each input used varying\nwith the\
  \ index counter.\n__kernel void blend_images(__write_only image2d_t dst,\n     \
  \                      unsigned int index,\n                           __read_only\
  \  image2d_t src1,\n                           __read_only  image2d_t src2)\n{\n\
  \    const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |\n                \
  \               CLK_FILTER_LINEAR);\n\n    float blend = (cos((float)index / 50.0f)\
  \ + 1.0f) / 2.0f;\n\n    int2  dst_loc = (int2)(get_global_id(0), get_global_id(1));\n\
  \    int2 src1_loc = dst_loc * get_image_dim(src1) / get_image_dim(dst);\n    int2\
  \ src2_loc = dst_loc * get_image_dim(src2) / get_image_dim(dst);\n\n    float4 val1\
  \ = read_imagef(src1, sampler, src1_loc);\n    float4 val2 = read_imagef(src2, sampler,\
  \ src2_loc);\n\n    write_imagef(dst, dst_loc, val1 * blend + val2 * (1.0f - blend));\n\
  }"
name: program_opencl
parameters:
- description: '<dd><p>OpenCL program source file.

    </p>

    </dd>'
  name: source
- description: '<dd><p>Kernel name in program.

    </p>

    </dd>'
  name: kernel
- description: '<dd><p>Number of inputs to the filter.  Defaults to 1.

    </p>

    </dd>'
  name: inputs
- description: '<dd><p>Size of output frames.  Defaults to the same as the first input.

    </p>

    </dd>'
  name: size, s
ref: https://ffmpeg.org/ffmpeg-filters.html#program_005fopencl
source: "<h3 class=\"section\"><a href=\"#toc-program_005fopencl-1\">12.12 program_opencl</a></h3>\n\
  \n<p>Filter video using an OpenCL program.\n</p>\n<dl compact=\"compact\">\n<dt><samp>source</samp></dt>\n\
  <dd><p>OpenCL program source file.\n</p>\n</dd>\n<dt><samp>kernel</samp></dt>\n\
  <dd><p>Kernel name in program.\n</p>\n</dd>\n<dt><samp>inputs</samp></dt>\n<dd><p>Number\
  \ of inputs to the filter.  Defaults to 1.\n</p>\n</dd>\n<dt><samp>size, s</samp></dt>\n\
  <dd><p>Size of output frames.  Defaults to the same as the first input.\n</p>\n\
  </dd>\n</dl>\n\n<p>The <code>program_opencl</code> filter also supports the <a href=\"\
  #framesync\">framesync</a> options.\n</p>\n<p>The program source file must contain\
  \ a kernel function with the given name,\nwhich will be run once for each plane\
  \ of the output.  Each run on a plane\ngets enqueued as a separate 2D global NDRange\
  \ with one work-item for each\npixel to be generated.  The global ID offset for\
  \ each work-item is therefore\nthe coordinates of a pixel in the destination image.\n\
  </p>\n<p>The kernel function needs to take the following arguments:\n</p><ul>\n\
  <li> Destination image, <var>__write_only image2d_t</var>.\n\n<p>This image will\
  \ become the output; the kernel should write all of it.\n</p></li><li> Frame index,\
  \ <var>unsigned int</var>.\n\n<p>This is a counter starting from zero and increasing\
  \ by one for each frame.\n</p></li><li> Source images, <var>__read_only image2d_t</var>.\n\
  \n<p>These are the most recent images on each input.  The kernel may read from\n\
  them to generate the output, but they can&rsquo;t be written to.\n</p></li></ul>\n\
  \n<p>Example programs:\n</p>\n<ul>\n<li> Copy the input to the output (output must\
  \ be the same size as the input).\n<pre class=\"verbatim\">__kernel void copy(__write_only\
  \ image2d_t destination,\n                   unsigned int index,\n             \
  \      __read_only  image2d_t source)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE;\n\
  \n    int2 location = (int2)(get_global_id(0), get_global_id(1));\n\n    float4\
  \ value = read_imagef(source, sampler, location);\n\n    write_imagef(destination,\
  \ location, value);\n}\n</pre>\n</li><li> Apply a simple transformation, rotating\
  \ the input by an amount increasing\nwith the index counter.  Pixel values are linearly\
  \ interpolated by the\nsampler, and the output need not have the same dimensions\
  \ as the input.\n<pre class=\"verbatim\">__kernel void rotate_image(__write_only\
  \ image2d_t dst,\n                           unsigned int index,\n             \
  \              __read_only  image2d_t src)\n{\n    const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE\
  \ |\n                               CLK_FILTER_LINEAR);\n\n    float angle = (float)index\
  \ / 100.0f;\n\n    float2 dst_dim = convert_float2(get_image_dim(dst));\n    float2\
  \ src_dim = convert_float2(get_image_dim(src));\n\n    float2 dst_cen = dst_dim\
  \ / 2.0f;\n    float2 src_cen = src_dim / 2.0f;\n\n    int2   dst_loc = (int2)(get_global_id(0),\
  \ get_global_id(1));\n\n    float2 dst_pos = convert_float2(dst_loc) - dst_cen;\n\
  \    float2 src_pos = {\n        cos(angle) * dst_pos.x - sin(angle) * dst_pos.y,\n\
  \        sin(angle) * dst_pos.x + cos(angle) * dst_pos.y\n    };\n    src_pos =\
  \ src_pos * src_dim / dst_dim;\n\n    float2 src_loc = src_pos + src_cen;\n\n  \
  \  if (src_loc.x &lt; 0.0f      || src_loc.y &lt; 0.0f ||\n        src_loc.x &gt;\
  \ src_dim.x || src_loc.y &gt; src_dim.y)\n        write_imagef(dst, dst_loc, 0.5f);\n\
  \    else\n        write_imagef(dst, dst_loc, read_imagef(src, sampler, src_loc));\n\
  }\n</pre>\n</li><li> Blend two inputs together, with the amount of each input used\
  \ varying\nwith the index counter.\n<pre class=\"verbatim\">__kernel void blend_images(__write_only\
  \ image2d_t dst,\n                           unsigned int index,\n             \
  \              __read_only  image2d_t src1,\n                           __read_only\
  \  image2d_t src2)\n{\n    const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE\
  \ |\n                               CLK_FILTER_LINEAR);\n\n    float blend = (cos((float)index\
  \ / 50.0f) + 1.0f) / 2.0f;\n\n    int2  dst_loc = (int2)(get_global_id(0), get_global_id(1));\n\
  \    int2 src1_loc = dst_loc * get_image_dim(src1) / get_image_dim(dst);\n    int2\
  \ src2_loc = dst_loc * get_image_dim(src2) / get_image_dim(dst);\n\n    float4 val1\
  \ = read_imagef(src1, sampler, src1_loc);\n    float4 val2 = read_imagef(src2, sampler,\
  \ src2_loc);\n\n    write_imagef(dst, dst_loc, val1 * blend + val2 * (1.0f - blend));\n\
  }\n</pre>\n</li></ul>\n\n"
