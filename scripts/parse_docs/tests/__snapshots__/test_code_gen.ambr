# serializer version: 1
# name: test_generate_class
  '''
  from typing import Any, Literal
  
  
  class FilterNode:
      def __init__(self, *stream: "Stream", name: str, **kwargs: Any) -> None:
          ...
  
      def stream(self) -> "Stream":
          raise NotImplementedError()
  
  
  class Stream:
      
      def atadenoise(
          self,*,_0a: float = None,
          _0b: float = None,
          _1a: float = None,
          _1b: float = None,
          _2a: float = None,
          _2b: float = None,
          s: int = None,
          p: str = None,
          a: Literal["p", "s"] = None,
          _0s: int = None,
          _1s: int = None,
          _2s: int = None,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.6 atadenoise Apply an Adaptive Temporal Averaging Denoiser to the video input. The filter accepts the following options:
  
          Parameters:
          ----------
          _0a:
              Set threshold A for 1st plane. Default is 0.02. Valid range is 0 to 0.3.
          _0b:
              Set threshold B for 1st plane. Default is 0.04. Valid range is 0 to 5.
          _1a:
              Set threshold A for 2nd plane. Default is 0.02. Valid range is 0 to 0.3.
          _1b:
              Set threshold B for 2nd plane. Default is 0.04. Valid range is 0 to 5.
          _2a:
              Set threshold A for 3rd plane. Default is 0.02. Valid range is 0 to 0.3.
          _2b:
              Set threshold B for 3rd plane. Default is 0.04. Valid range is 0 to 5. Threshold A is designed to react on abrupt changes in the input signal and threshold B is designed to react on continuous changes in the input signal.
          s:
              Set number of frames filter will use for averaging. Default is 9. Must be odd number in range [5, 129].
          p:
              Set what planes of frame filter will use for averaging. Default is all.
          a:
              Set what variant of algorithm filter will use for averaging. Default is p parallel. Alternatively can be set to s serial. Parallel can be faster then serial, while other way around is never true. Parallel will abort early on first change being greater then thresholds, while serial will continue processing other side of frames if they are equal or below thresholds.
          _0s:
              Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767. Valid range is from 0 to 32767. This options controls weight for each pixel in radius defined by size. Default value means every pixel have same weight. Setting this option to 0 effectively disables filtering.
          _1s:
              Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767. Valid range is from 0 to 32767. This options controls weight for each pixel in radius defined by size. Default value means every pixel have same weight. Setting this option to 0 effectively disables filtering.
          _2s:
              Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767. Valid range is from 0 to 32767. This options controls weight for each pixel in radius defined by size. Default value means every pixel have same weight. Setting this option to 0 effectively disables filtering.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#atadenoise
  
          """
          return FilterNode(
              *[self],
              name="atadenoise",
              kwargs={
                  
                  "0a": _0a,
                  "0b": _0b,
                  "1a": _1a,
                  "1b": _1b,
                  "2a": _2a,
                  "2b": _2b,
                  "s": s,
                  "p": p,
                  "a": a,
                  "0s": _0s,
                  "1s": _1s,
                  "2s": _2s,
                  **kwargs
              }
          ).stream()
      
      def hwupload(
          self,*,derive_device: str ,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.123 hwupload Upload system memory frames to hardware surfaces. The device to upload to must be supplied when the filter is initialised. If using ffmpeg, select the appropriate device with the -filter_hw_device option or with the derive_device option. The input and output devices must be of different types and compatible - the exact meaning of this is system-dependent, but typically it means that they must refer to the same underlying hardware context (for example, refer to the same graphics card). The following additional parameters are accepted:
  
          Parameters:
          ----------
          derive_device:
              Rather than using the device supplied at initialisation, instead derive a new device of type type from the device the input frames exist on.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#hwupload
  
          """
          return FilterNode(
              *[self],
              name="hwupload",
              kwargs={
                  
                  "derive_device": derive_device,
                  **kwargs
              }
          ).stream()
      
      def stereo3d(
          self,*,_in: Literal["sbsl", "sbsr", "sbs2l", "sbs2r", "abl", "tbl", "abr", "tbr", "ab2l", "tb2l", "ab2r", "tb2r", "al", "ar", "irl", "irr", "icl", "icr"] = None,
          out: Literal["sbsl", "sbsr", "sbs2l", "sbs2r", "abl", "tbl", "abr", "tbr", "ab2l", "tb2l", "ab2r", "tb2r", "al", "ar", "irl", "irr", "arbg", "argg", "arcg", "arch", "arcc", "arcd", "agmg", "agmh", "agmc", "agmd", "aybg", "aybh", "aybc", "aybd", "ml", "mr", "chl", "chr", "icl", "icr", "hdmi"] = None,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.244 stereo3d Convert between different stereoscopic image formats. The filters accept the following options:
  
          Parameters:
          ----------
          _in:
              Set stereoscopic image format of input. Available values for input image formats are: ‘sbsl’ side by side parallel (left eye left, right eye right) ‘sbsr’ side by side crosseye (right eye left, left eye right) ‘sbs2l’ side by side parallel with half width resolution (left eye left, right eye right) ‘sbs2r’ side by side crosseye with half width resolution (right eye left, left eye right) ‘abl’ ‘tbl’ above-below (left eye above, right eye below) ‘abr’ ‘tbr’ above-below (right eye above, left eye below) ‘ab2l’ ‘tb2l’ above-below with half height resolution (left eye above, right eye below) ‘ab2r’ ‘tb2r’ above-below with half height resolution (right eye above, left eye below) ‘al’ alternating frames (left eye first, right eye second) ‘ar’ alternating frames (right eye first, left eye second) ‘irl’ interleaved rows (left eye has top row, right eye starts on next row) ‘irr’ interleaved rows (right eye has top row, left eye starts on next row) ‘icl’ interleaved columns, left eye first ‘icr’ interleaved columns, right eye first Default value is ‘sbsl’.
          out:
              Set stereoscopic image format of output. ‘sbsl’ side by side parallel (left eye left, right eye right) ‘sbsr’ side by side crosseye (right eye left, left eye right) ‘sbs2l’ side by side parallel with half width resolution (left eye left, right eye right) ‘sbs2r’ side by side crosseye with half width resolution (right eye left, left eye right) ‘abl’ ‘tbl’ above-below (left eye above, right eye below) ‘abr’ ‘tbr’ above-below (right eye above, left eye below) ‘ab2l’ ‘tb2l’ above-below with half height resolution (left eye above, right eye below) ‘ab2r’ ‘tb2r’ above-below with half height resolution (right eye above, left eye below) ‘al’ alternating frames (left eye first, right eye second) ‘ar’ alternating frames (right eye first, left eye second) ‘irl’ interleaved rows (left eye has top row, right eye starts on next row) ‘irr’ interleaved rows (right eye has top row, left eye starts on next row) ‘arbg’ anaglyph red/blue gray (red filter on left eye, blue filter on right eye) ‘argg’ anaglyph red/green gray (red filter on left eye, green filter on right eye) ‘arcg’ anaglyph red/cyan gray (red filter on left eye, cyan filter on right eye) ‘arch’ anaglyph red/cyan half colored (red filter on left eye, cyan filter on right eye) ‘arcc’ anaglyph red/cyan color (red filter on left eye, cyan filter on right eye) ‘arcd’ anaglyph red/cyan color optimized with the least squares projection of dubois (red filter on left eye, cyan filter on right eye) ‘agmg’ anaglyph green/magenta gray (green filter on left eye, magenta filter on right eye) ‘agmh’ anaglyph green/magenta half colored (green filter on left eye, magenta filter on right eye) ‘agmc’ anaglyph green/magenta colored (green filter on left eye, magenta filter on right eye) ‘agmd’ anaglyph green/magenta color optimized with the least squares projection of dubois (green filter on left eye, magenta filter on right eye) ‘aybg’ anaglyph yellow/blue gray (yellow filter on left eye, blue filter on right eye) ‘aybh’ anaglyph yellow/blue half colored (yellow filter on left eye, blue filter on right eye) ‘aybc’ anaglyph yellow/blue colored (yellow filter on left eye, blue filter on right eye) ‘aybd’ anaglyph yellow/blue color optimized with the least squares projection of dubois (yellow filter on left eye, blue filter on right eye) ‘ml’ mono output (left eye only) ‘mr’ mono output (right eye only) ‘chl’ checkerboard, left eye first ‘chr’ checkerboard, right eye first ‘icl’ interleaved columns, left eye first ‘icr’ interleaved columns, right eye first ‘hdmi’ HDMI frame pack Default value is ‘arcd’.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#stereo3d
  
          """
          return FilterNode(
              *[self],
              name="stereo3d",
              kwargs={
                  
                  "in": _in,
                  "out": out,
                  **kwargs
              }
          ).stream()
      
      def xmedian(
          self,*,inputs: int = None,
          planes: int = None,
          percentile: float = None,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.288 xmedian Pick median pixels from several input videos. The filter accepts the following options:
  
          Parameters:
          ----------
          inputs:
              Set number of inputs. Default is 3. Allowed range is from 3 to 255. If number of inputs is even number, than result will be mean value between two median values.
          planes:
              Set which planes to filter. Default value is 15, by which all planes are processed.
          percentile:
              Set median percentile. Default value is 0.5. Default value of 0.5 will pick always median values, while 0 will pick minimum values, and 1 maximum values.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#xmedian
  
          """
          return FilterNode(
              *[self],
              name="xmedian",
              kwargs={
                  
                  "inputs": inputs,
                  "planes": planes,
                  "percentile": percentile,
                  **kwargs
              }
          ).stream()
      
  '''
# ---
# name: test_generate_filter_to_method[atadenoise.json]
  '''
      def atadenoise(
          self,*,_0a: float = None,
          _0b: float = None,
          _1a: float = None,
          _1b: float = None,
          _2a: float = None,
          _2b: float = None,
          s: int = None,
          p: str = None,
          a: Literal["p", "s"] = None,
          _0s: int = None,
          _1s: int = None,
          _2s: int = None,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.6 atadenoise Apply an Adaptive Temporal Averaging Denoiser to the video input. The filter accepts the following options:
  
          Parameters:
          ----------
          _0a:
              Set threshold A for 1st plane. Default is 0.02. Valid range is 0 to 0.3.
          _0b:
              Set threshold B for 1st plane. Default is 0.04. Valid range is 0 to 5.
          _1a:
              Set threshold A for 2nd plane. Default is 0.02. Valid range is 0 to 0.3.
          _1b:
              Set threshold B for 2nd plane. Default is 0.04. Valid range is 0 to 5.
          _2a:
              Set threshold A for 3rd plane. Default is 0.02. Valid range is 0 to 0.3.
          _2b:
              Set threshold B for 3rd plane. Default is 0.04. Valid range is 0 to 5. Threshold A is designed to react on abrupt changes in the input signal and threshold B is designed to react on continuous changes in the input signal.
          s:
              Set number of frames filter will use for averaging. Default is 9. Must be odd number in range [5, 129].
          p:
              Set what planes of frame filter will use for averaging. Default is all.
          a:
              Set what variant of algorithm filter will use for averaging. Default is p parallel. Alternatively can be set to s serial. Parallel can be faster then serial, while other way around is never true. Parallel will abort early on first change being greater then thresholds, while serial will continue processing other side of frames if they are equal or below thresholds.
          _0s:
              Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767. Valid range is from 0 to 32767. This options controls weight for each pixel in radius defined by size. Default value means every pixel have same weight. Setting this option to 0 effectively disables filtering.
          _1s:
              Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767. Valid range is from 0 to 32767. This options controls weight for each pixel in radius defined by size. Default value means every pixel have same weight. Setting this option to 0 effectively disables filtering.
          _2s:
              Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767. Valid range is from 0 to 32767. This options controls weight for each pixel in radius defined by size. Default value means every pixel have same weight. Setting this option to 0 effectively disables filtering.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#atadenoise
  
          """
          return FilterNode(
              *[self],
              name="atadenoise",
              kwargs={
                  
                  "0a": _0a,
                  "0b": _0b,
                  "1a": _1a,
                  "1b": _1b,
                  "2a": _2a,
                  "2b": _2b,
                  "s": s,
                  "p": p,
                  "a": a,
                  "0s": _0s,
                  "1s": _1s,
                  "2s": _2s,
                  **kwargs
              }
          ).stream()
  '''
# ---
# name: test_generate_filter_to_method[hwupload.json]
  '''
      def hwupload(
          self,*,derive_device: str ,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.123 hwupload Upload system memory frames to hardware surfaces. The device to upload to must be supplied when the filter is initialised. If using ffmpeg, select the appropriate device with the -filter_hw_device option or with the derive_device option. The input and output devices must be of different types and compatible - the exact meaning of this is system-dependent, but typically it means that they must refer to the same underlying hardware context (for example, refer to the same graphics card). The following additional parameters are accepted:
  
          Parameters:
          ----------
          derive_device:
              Rather than using the device supplied at initialisation, instead derive a new device of type type from the device the input frames exist on.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#hwupload
  
          """
          return FilterNode(
              *[self],
              name="hwupload",
              kwargs={
                  
                  "derive_device": derive_device,
                  **kwargs
              }
          ).stream()
  '''
# ---
# name: test_generate_filter_to_method[stereo3d.json]
  '''
      def stereo3d(
          self,*,_in: Literal["sbsl", "sbsr", "sbs2l", "sbs2r", "abl", "tbl", "abr", "tbr", "ab2l", "tb2l", "ab2r", "tb2r", "al", "ar", "irl", "irr", "icl", "icr"] = None,
          out: Literal["sbsl", "sbsr", "sbs2l", "sbs2r", "abl", "tbl", "abr", "tbr", "ab2l", "tb2l", "ab2r", "tb2r", "al", "ar", "irl", "irr", "arbg", "argg", "arcg", "arch", "arcc", "arcd", "agmg", "agmh", "agmc", "agmd", "aybg", "aybh", "aybc", "aybd", "ml", "mr", "chl", "chr", "icl", "icr", "hdmi"] = None,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.244 stereo3d Convert between different stereoscopic image formats. The filters accept the following options:
  
          Parameters:
          ----------
          _in:
              Set stereoscopic image format of input. Available values for input image formats are: ‘sbsl’ side by side parallel (left eye left, right eye right) ‘sbsr’ side by side crosseye (right eye left, left eye right) ‘sbs2l’ side by side parallel with half width resolution (left eye left, right eye right) ‘sbs2r’ side by side crosseye with half width resolution (right eye left, left eye right) ‘abl’ ‘tbl’ above-below (left eye above, right eye below) ‘abr’ ‘tbr’ above-below (right eye above, left eye below) ‘ab2l’ ‘tb2l’ above-below with half height resolution (left eye above, right eye below) ‘ab2r’ ‘tb2r’ above-below with half height resolution (right eye above, left eye below) ‘al’ alternating frames (left eye first, right eye second) ‘ar’ alternating frames (right eye first, left eye second) ‘irl’ interleaved rows (left eye has top row, right eye starts on next row) ‘irr’ interleaved rows (right eye has top row, left eye starts on next row) ‘icl’ interleaved columns, left eye first ‘icr’ interleaved columns, right eye first Default value is ‘sbsl’.
          out:
              Set stereoscopic image format of output. ‘sbsl’ side by side parallel (left eye left, right eye right) ‘sbsr’ side by side crosseye (right eye left, left eye right) ‘sbs2l’ side by side parallel with half width resolution (left eye left, right eye right) ‘sbs2r’ side by side crosseye with half width resolution (right eye left, left eye right) ‘abl’ ‘tbl’ above-below (left eye above, right eye below) ‘abr’ ‘tbr’ above-below (right eye above, left eye below) ‘ab2l’ ‘tb2l’ above-below with half height resolution (left eye above, right eye below) ‘ab2r’ ‘tb2r’ above-below with half height resolution (right eye above, left eye below) ‘al’ alternating frames (left eye first, right eye second) ‘ar’ alternating frames (right eye first, left eye second) ‘irl’ interleaved rows (left eye has top row, right eye starts on next row) ‘irr’ interleaved rows (right eye has top row, left eye starts on next row) ‘arbg’ anaglyph red/blue gray (red filter on left eye, blue filter on right eye) ‘argg’ anaglyph red/green gray (red filter on left eye, green filter on right eye) ‘arcg’ anaglyph red/cyan gray (red filter on left eye, cyan filter on right eye) ‘arch’ anaglyph red/cyan half colored (red filter on left eye, cyan filter on right eye) ‘arcc’ anaglyph red/cyan color (red filter on left eye, cyan filter on right eye) ‘arcd’ anaglyph red/cyan color optimized with the least squares projection of dubois (red filter on left eye, cyan filter on right eye) ‘agmg’ anaglyph green/magenta gray (green filter on left eye, magenta filter on right eye) ‘agmh’ anaglyph green/magenta half colored (green filter on left eye, magenta filter on right eye) ‘agmc’ anaglyph green/magenta colored (green filter on left eye, magenta filter on right eye) ‘agmd’ anaglyph green/magenta color optimized with the least squares projection of dubois (green filter on left eye, magenta filter on right eye) ‘aybg’ anaglyph yellow/blue gray (yellow filter on left eye, blue filter on right eye) ‘aybh’ anaglyph yellow/blue half colored (yellow filter on left eye, blue filter on right eye) ‘aybc’ anaglyph yellow/blue colored (yellow filter on left eye, blue filter on right eye) ‘aybd’ anaglyph yellow/blue color optimized with the least squares projection of dubois (yellow filter on left eye, blue filter on right eye) ‘ml’ mono output (left eye only) ‘mr’ mono output (right eye only) ‘chl’ checkerboard, left eye first ‘chr’ checkerboard, right eye first ‘icl’ interleaved columns, left eye first ‘icr’ interleaved columns, right eye first ‘hdmi’ HDMI frame pack Default value is ‘arcd’.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#stereo3d
  
          """
          return FilterNode(
              *[self],
              name="stereo3d",
              kwargs={
                  
                  "in": _in,
                  "out": out,
                  **kwargs
              }
          ).stream()
  '''
# ---
# name: test_generate_filter_to_method[xmedian.json]
  '''
      def xmedian(
          self,*,inputs: int = None,
          planes: int = None,
          percentile: float = None,
          **kwargs: dict[str, Any]
      ) -> "Stream":
          """
          11.288 xmedian Pick median pixels from several input videos. The filter accepts the following options:
  
          Parameters:
          ----------
          inputs:
              Set number of inputs. Default is 3. Allowed range is from 3 to 255. If number of inputs is even number, than result will be mean value between two median values.
          planes:
              Set which planes to filter. Default value is 15, by which all planes are processed.
          percentile:
              Set median percentile. Default value is 0.5. Default value of 0.5 will pick always median values, while 0 will pick minimum values, and 1 maximum values.
          
  
  
          Example usage:
          --------------
  
          Ref: https://ffmpeg.org/ffmpeg-filters.html#xmedian
  
          """
          return FilterNode(
              *[self],
              name="xmedian",
              kwargs={
                  
                  "inputs": inputs,
                  "planes": planes,
                  "percentile": percentile,
                  **kwargs
              }
          ).stream()
  '''
# ---
