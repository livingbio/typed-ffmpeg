{
  "description": "### 11.134 identity\n\nObtain the identity score between two input videos.\n\nThis filter takes two input videos.\n\nBoth input videos must have the same resolution and pixel format for this\nfilter to work correctly. Also it assumes that both inputs have the same\nnumber of frames, which are compared one by one.\n\nThe obtained per component, average, min and max identity score is printed\nthrough the logging system.\n\nThe filter stores the calculated identity scores of each frame in frame\nmetadata.\n\nThis filter also supports the framesync options.\n\nIn the below example the input file main.mpg being processed is compared with\nthe reference file ref.mpg.\n\n    \n    \n    ffmpeg -i main.mpg -i ref.mpg -lavfi identity -f null -\n    \n\n",
  "filter_type": "vf",
  "formula_input_typings": null,
  "formula_output_typings": null,
  "id": "ff_vf_identity",
  "input_stream_typings": [
    {
      "name": "main",
      "type": "AVMEDIA_TYPE_VIDEO"
    },
    {
      "name": "reference",
      "type": "AVMEDIA_TYPE_VIDEO"
    }
  ],
  "is_input_dynamic": false,
  "is_output_dynamic": false,
  "is_support_framesync": true,
  "is_support_timeline": true,
  "name": "identity",
  "options": [
    {
      "alias": [],
      "choices": [],
      "default": null,
      "description": "timeline editing",
      "name": "enable",
      "required": false,
      "typing": "str"
    },
    {
      "alias": [],
      "choices": [
        {
          "help": "Repeat the last frame.",
          "name": "repeat",
          "value": "repeat"
        },
        {
          "help": "End both streams.",
          "name": "endall",
          "value": "endall"
        },
        {
          "help": "Pass the main input through.",
          "name": "pass",
          "value": "pass"
        }
      ],
      "default": "repeat",
      "description": "The action to take when EOF is encountered on the secondary input; it accepts one of the following values",
      "name": "eof_action",
      "required": false,
      "typing": "str"
    },
    {
      "alias": [],
      "choices": [],
      "default": 0,
      "description": "Force the output to terminate when the shortest input terminates.",
      "name": "shortest",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [],
      "choices": [],
      "default": 1,
      "description": "force the filter to extend the last frame of secondary streams until the end of the primary stream.",
      "name": "repeatlast",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [],
      "choices": [
        {
          "help": "Frame from secondary input with the nearest lower or equal timestamp to the primary input frame.",
          "name": "default",
          "value": "default"
        },
        {
          "help": "Frame from secondary input with the absolute nearest timestamp to the primary input frame.",
          "name": "nearest",
          "value": "nearest"
        }
      ],
      "default": "default",
      "description": "How strictly to sync streams based on secondary input timestamps; it accepts one of the following values:",
      "name": "ts_sync_mode",
      "required": false,
      "typing": "str"
    }
  ],
  "output_stream_typings": [
    {
      "name": "default",
      "type": "AVMEDIA_TYPE_VIDEO"
    }
  ],
  "ref": "https://ffmpeg.org/ffmpeg-filters.html#identity"
}
