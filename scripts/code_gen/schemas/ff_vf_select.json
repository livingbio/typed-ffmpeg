{
  "description": "### 18.17 select, aselect\n\nSelect frames to pass in output.\n\nThis filter accepts the following options:\n\n**expr, e**\n\n    Set expression, which is evaluated for each input frame. If the expression is evaluated to zero, the frame is discarded. If the evaluation result is negative or NaN, the frame is sent to the first output; otherwise it is sent to the output with index ceil(val)-1, assuming that the input index starts from 0. For example a value of 1.2 corresponds to the output with index ceil(1.2)-1 = 2-1 = 1, that is the second output. \n\n**outputs, n**\n\n    Set the number of outputs. The output to which to send the selected frame is based on the result of the evaluation. Default value is 1. \n\nThe expression can contain the following constants:\n\n**n**\n\n    The (sequential) number of the filtered frame, starting from 0. \n\n**selected_n**\n\n    The (sequential) number of the selected frame, starting from 0. \n\n**prev_selected_n**\n\n    The sequential number of the last selected frame. It\u2019s NAN if undefined. \n\n**TB**\n\n    The timebase of the input timestamps. \n\n**pts**\n\n    The PTS (Presentation TimeStamp) of the filtered frame, expressed in TB units. It\u2019s NAN if undefined. \n\n**t**\n\n    The PTS of the filtered frame, expressed in seconds. It\u2019s NAN if undefined. \n\n**prev_pts**\n\n    The PTS of the previously filtered frame. It\u2019s NAN if undefined. \n\n**prev_selected_pts**\n\n    The PTS of the last previously filtered frame. It\u2019s NAN if undefined. \n\n**prev_selected_t**\n\n    The PTS of the last previously selected frame, expressed in seconds. It\u2019s NAN if undefined. \n\n**start_pts**\n\n    The first PTS in the stream which is not NAN. It remains NAN if not found. \n\n**start_t**\n\n    The first PTS, in seconds, in the stream which is not NAN. It remains NAN if not found. \n\n**pict_type (video only)**\n\n    The type of the filtered frame. It can assume one of the following values: I P B S SI SP BI \n\n**interlace_type (video only)**\n\n    The frame interlace type. It can assume one of the following values: PROGRESSIVE The frame is progressive (not interlaced). TOPFIRST The frame is top-field-first. BOTTOMFIRST The frame is bottom-field-first. \n\n**consumed_sample_n (audio only)**\n\n    the number of selected samples before the current frame \n\n**samples_n (audio only)**\n\n    the number of samples in the current frame \n\n**sample_rate (audio only)**\n\n    the input sample rate \n\n**key**\n\n    This is 1 if the filtered frame is a key-frame, 0 otherwise. \n\n**pos**\n\n    the position in the file of the filtered frame, -1 if the information is not available (e.g. for synthetic video); deprecated, do not use \n\n**scene (video only)**\n\n    value between 0 and 1 to indicate a new scene; a low value reflects a low probability for the current frame to introduce a new scene, while a higher value means the current frame is more likely to be one (see the example below) \n\n**concatdec_select**\n\n    The concat demuxer can select only part of a concat input file by setting an inpoint and an outpoint, but the output packets may not be entirely contained in the selected interval. By using this variable, it is possible to skip frames generated by the concat demuxer which are not exactly contained in the selected interval. This works by comparing the frame pts against the lavf.concat.start_time and the lavf.concat.duration packet metadata values which are also present in the decoded frames. The concatdec_select variable is -1 if the frame pts is at least start_time and either the duration metadata is missing or the frame pts is less than start_time + duration, 0 otherwise, and NaN if the start_time metadata is missing. That basically means that an input frame is selected if its pts is within the interval set by the concat demuxer. \n\nThe default value of the select expression is \"1\".\n\n",
  "filter_type": "vf",
  "formula_input_typings": null,
  "formula_output_typings": "[StreamType.video] * int(outputs)",
  "id": "ff_vf_select",
  "input_stream_typings": [
    {
      "name": "default",
      "type": "AVMEDIA_TYPE_VIDEO"
    }
  ],
  "is_input_dynamic": false,
  "is_output_dynamic": true,
  "is_support_framesync": false,
  "is_support_timeline": false,
  "name": "select",
  "options": [
    {
      "alias": [
        "expr",
        "e"
      ],
      "choices": [],
      "default": "1",
      "description": "<dd><p>Set expression, which is evaluated for each input frame.\n</p>\n<p>If the expression is evaluated to zero, the frame is discarded.\n</p>\n<p>If the evaluation result is negative or NaN, the frame is sent to the\nfirst output; otherwise it is sent to the output with index\n<code>ceil(val)-1</code>, assuming that the input index starts from 0.\n</p>\n<p>For example a value of <code>1.2</code> corresponds to the output with index\n<code>ceil(1.2)-1 = 2-1 = 1</code>, that is the second output.\n</p>\n</dd>",
      "name": "expr",
      "required": false,
      "typing": "str"
    },
    {
      "alias": [
        "outputs",
        "n"
      ],
      "choices": [],
      "default": 1,
      "description": "<dd><p>Set the number of outputs. The output to which to send the selected\nframe is based on the result of the evaluation. Default value is 1.\n</p></dd>",
      "name": "outputs",
      "required": false,
      "typing": "int"
    }
  ],
  "output_stream_typings": [],
  "ref": "https://ffmpeg.org/ffmpeg-filters.html#select_002c-aselect"
}
