{
  "description": "### 18.17 select, aselect\n\nSelect frames to pass in output.\n\n\nThis filter accepts the following options:\n\n\n- **`expr, e`**\n  - Set expression, which is evaluated for each input frame.\nIf the expression is evaluated to zero, the frame is discarded.\nIf the evaluation result is negative or NaN, the frame is sent to the\nfirst output; otherwise it is sent to the output with index\nceil(val)-1\n, assuming that the input index starts from 0.\nFor example a value of\n1.2\ncorresponds to the output with index\nceil(1.2)-1 = 2-1 = 1\n, that is the second output.\n- **`outputs, n`**\n  - Set the number of outputs. The output to which to send the selected\nframe is based on the result of the evaluation. Default value is 1.\nSet expression, which is evaluated for each input frame.\n\n\nIf the expression is evaluated to zero, the frame is discarded.\n\n\nIf the evaluation result is negative or NaN, the frame is sent to the\nfirst output; otherwise it is sent to the output with index\nceil(val)-1, assuming that the input index starts from 0.\n\n\nFor example a value of 1.2 corresponds to the output with index\nceil(1.2)-1 = 2-1 = 1, that is the second output.\n\n\nSet the number of outputs. The output to which to send the selected\nframe is based on the result of the evaluation. Default value is 1.\n\n\nThe expression can contain the following constants:\n\n\n- **`n`**\n  - The (sequential) number of the filtered frame, starting from 0.\n- **`selected_n`**\n  - The (sequential) number of the selected frame, starting from 0.\n- **`prev_selected_n`**\n  - The sequential number of the last selected frame. It\u2019s NAN if undefined.\n- **`TB`**\n  - The timebase of the input timestamps.\n- **`pts`**\n  - The PTS (Presentation TimeStamp) of the filtered frame,\nexpressed in\nTB\nunits. It\u2019s NAN if undefined.\n- **`t`**\n  - The PTS of the filtered frame,\nexpressed in seconds. It\u2019s NAN if undefined.\n- **`prev_pts`**\n  - The PTS of the previously filtered frame. It\u2019s NAN if undefined.\n- **`prev_selected_pts`**\n  - The PTS of the last previously filtered frame. It\u2019s NAN if undefined.\n- **`prev_selected_t`**\n  - The PTS of the last previously selected frame, expressed in seconds. It\u2019s NAN if undefined.\n- **`start_pts`**\n  - The first PTS in the stream which is not NAN. It remains NAN if not found.\n- **`start_t`**\n  - The first PTS, in seconds, in the stream which is not NAN. It remains NAN if not found.\n- **`pict_type(video only)`**\n  - The type of the filtered frame. It can assume one of the following\nvalues:\nI\nP\nB\nS\nSI\nSP\nBI\n- **`interlace_type(video only)`**\n  - The frame interlace type. It can assume one of the following values:\nPROGRESSIVE\nThe frame is progressive (not interlaced).\nTOPFIRST\nThe frame is top-field-first.\nBOTTOMFIRST\nThe frame is bottom-field-first.\n- **`consumed_sample_n(audio only)`**\n  - the number of selected samples before the current frame\n- **`samples_n(audio only)`**\n  - the number of samples in the current frame\n- **`sample_rate(audio only)`**\n  - the input sample rate\n- **`key`**\n  - This is 1 if the filtered frame is a key-frame, 0 otherwise.\n- **`pos`**\n  - the position in the file of the filtered frame, -1 if the information\nis not available (e.g. for synthetic video); deprecated, do not use\n- **`scene(video only)`**\n  - value between 0 and 1 to indicate a new scene; a low value reflects a low\nprobability for the current frame to introduce a new scene, while a higher\nvalue means the current frame is more likely to be one (see the example below)\n- **`concatdec_select`**\n  - The concat demuxer can select only part of a concat input file by setting an\ninpoint and an outpoint, but the output packets may not be entirely contained\nin the selected interval. By using this variable, it is possible to skip frames\ngenerated by the concat demuxer which are not exactly contained in the selected\ninterval.\nThis works by comparing the frame pts against the\nlavf.concat.start_time\nand the\nlavf.concat.duration\npacket metadata values which are also\npresent in the decoded frames.\nThe\nconcatdec_select\nvariable is -1 if the frame pts is at least\nstart_time and either the duration metadata is missing or the frame pts is less\nthan start_time + duration, 0 otherwise, and NaN if the start_time metadata is\nmissing.\nThat basically means that an input frame is selected if its pts is within the\ninterval set by the concat demuxer.\nThe (sequential) number of the filtered frame, starting from 0.\n\n\nThe (sequential) number of the selected frame, starting from 0.\n\n\nThe sequential number of the last selected frame. It\u2019s NAN if undefined.\n\n\nThe timebase of the input timestamps.\n\n\nThe PTS (Presentation TimeStamp) of the filtered frame,\nexpressed in TB units. It\u2019s NAN if undefined.\n\n\nThe PTS of the filtered frame,\nexpressed in seconds. It\u2019s NAN if undefined.\n\n\nThe PTS of the previously filtered frame. It\u2019s NAN if undefined.\n\n\nThe PTS of the last previously filtered frame. It\u2019s NAN if undefined.\n\n\nThe PTS of the last previously selected frame, expressed in seconds. It\u2019s NAN if undefined.\n\n\nThe first PTS in the stream which is not NAN. It remains NAN if not found.\n\n\nThe first PTS, in seconds, in the stream which is not NAN. It remains NAN if not found.\n\n\nThe type of the filtered frame. It can assume one of the following\nvalues:\n\n\n- **`I`**\n- **`P`**\n- **`B`**\n- **`S`**\n- **`SI`**\n- **`SP`**\n- **`BI`**\nThe frame interlace type. It can assume one of the following values:\n\n\n- **`PROGRESSIVE`**\n  - The frame is progressive (not interlaced).\n- **`TOPFIRST`**\n  - The frame is top-field-first.\n- **`BOTTOMFIRST`**\n  - The frame is bottom-field-first.\nThe frame is progressive (not interlaced).\n\n\nThe frame is top-field-first.\n\n\nThe frame is bottom-field-first.\n\n\nthe number of selected samples before the current frame\n\n\nthe number of samples in the current frame\n\n\nthe input sample rate\n\n\nThis is 1 if the filtered frame is a key-frame, 0 otherwise.\n\n\nthe position in the file of the filtered frame, -1 if the information\nis not available (e.g. for synthetic video); deprecated, do not use\n\n\nvalue between 0 and 1 to indicate a new scene; a low value reflects a low\nprobability for the current frame to introduce a new scene, while a higher\nvalue means the current frame is more likely to be one (see the example below)\n\n\nThe concat demuxer can select only part of a concat input file by setting an\ninpoint and an outpoint, but the output packets may not be entirely contained\nin the selected interval. By using this variable, it is possible to skip frames\ngenerated by the concat demuxer which are not exactly contained in the selected\ninterval.\n\n\nThis works by comparing the frame pts against the lavf.concat.start_time\nand the lavf.concat.duration packet metadata values which are also\npresent in the decoded frames.\n\n\nThe concatdec_select variable is -1 if the frame pts is at least\nstart_time and either the duration metadata is missing or the frame pts is less\nthan start_time + duration, 0 otherwise, and NaN if the start_time metadata is\nmissing.\n\n\nThat basically means that an input frame is selected if its pts is within the\ninterval set by the concat demuxer.\n\n\nThe default value of the select expression is \"1\".\n\n\n",
  "filter_type": "af",
  "formula_input_typings": null,
  "formula_output_typings": "[StreamType.audio] * outputs",
  "id": "ff_af_aselect",
  "input_stream_typings": [
    {
      "name": "default",
      "type": "AVMEDIA_TYPE_AUDIO"
    }
  ],
  "is_input_dynamic": false,
  "is_output_dynamic": true,
  "name": "aselect",
  "options": [
    {
      "alias": [
        "expr",
        "e"
      ],
      "choices": [],
      "default": "1",
      "description": "<dd><p>Set expression, which is evaluated for each input frame.\n</p>\n<p>If the expression is evaluated to zero, the frame is discarded.\n</p>\n<p>If the evaluation result is negative or NaN, the frame is sent to the\nfirst output; otherwise it is sent to the output with index\n<code>ceil(val)-1</code>, assuming that the input index starts from 0.\n</p>\n<p>For example a value of <code>1.2</code> corresponds to the output with index\n<code>ceil(1.2)-1 = 2-1 = 1</code>, that is the second output.\n</p>\n</dd>",
      "name": "expr",
      "required": false,
      "typing": "str"
    },
    {
      "alias": [
        "outputs",
        "n"
      ],
      "choices": [],
      "default": 1,
      "description": "<dd><p>Set the number of outputs. The output to which to send the selected\nframe is based on the result of the evaluation. Default value is 1.\n</p></dd>",
      "name": "outputs",
      "required": false,
      "typing": "int"
    }
  ],
  "output_stream_typings": [],
  "ref": "https://ffmpeg.org/ffmpeg-filters.html#select_002c-aselect"
}
