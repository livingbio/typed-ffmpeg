{
  "description": "### 11.94 fieldmatch\n\nField matching filter for inverse telecine. It is meant to reconstruct the\nprogressive frames from a telecined stream. The filter does not drop duplicated\nframes, so to achieve a complete inverse telecine fieldmatch needs to be\nfollowed by a decimation filter such as decimate in the filtergraph.\n\n\nThe separation of the field matching and the decimation is notably motivated by\nthe possibility of inserting a de-interlacing filter fallback between the two.\nIf the source has mixed telecined and real interlaced content,\nfieldmatch will not be able to match fields for the interlaced parts.\nBut these remaining combed frames will be marked as interlaced, and thus can be\nde-interlaced by a later filter such as yadif before decimation.\n\n\nIn addition to the various configuration options, fieldmatch can take an\noptional second stream, activated through the ppsrc option. If\nenabled, the frames reconstruction will be based on the fields and frames from\nthis second stream. This allows the first input to be pre-processed in order to\nhelp the various algorithms of the filter, while keeping the output lossless\n(assuming the fields are matched properly). Typically, a field-aware denoiser,\nor brightness/contrast adjustments can help.\n\n\nNote that this filter uses the same algorithms as TIVTC/TFM (AviSynth project)\nand VIVTC/VFM (VapourSynth project). The later is a light clone of TFM from\nwhich fieldmatch is based on. While the semantic and usage are very\nclose, some behaviour and options names can differ.\n\n\nThe decimate filter currently only works for constant frame rate input.\nIf your input has mixed telecined (30fps) and progressive content with a lower\nframerate like 24fps use the following filterchain to produce the necessary cfr\nstream: dejudder,fps=30000/1001,fieldmatch,decimate.\n\n\nThe filter accepts the following options:\n\n\n- **`order`**\n  - Specify the assumed field order of the input stream. Available values are:\n\u2018\nauto\n\u2019\nAuto detect parity (use FFmpeg\u2019s internal parity value).\n\u2018\nbff\n\u2019\nAssume bottom field first.\n\u2018\ntff\n\u2019\nAssume top field first.\nNote that it is sometimes recommended not to trust the parity announced by the\nstream.\nDefault value is\nauto\n.\n- **`mode`**\n  - Set the matching mode or strategy to use.\npc\nmode is the safest in the\nsense that it won\u2019t risk creating jerkiness due to duplicate frames when\npossible, but if there are bad edits or blended fields it will end up\noutputting combed frames when a good match might actually exist. On the other\nhand,\npcn_ub\nmode is the most risky in terms of creating jerkiness,\nbut will almost always find a good frame if there is one. The other values are\nall somewhere in between\npc\nand\npcn_ub\nin terms of risking\njerkiness and creating duplicate frames versus finding good matches in sections\nwith bad edits, orphaned fields, blended fields, etc.\nMore details about p/c/n/u/b are available in\np/c/n/u/b meaning\nsection.\nAvailable values are:\n\u2018\npc\n\u2019\n2-way matching (p/c)\n\u2018\npc_n\n\u2019\n2-way matching, and trying 3rd match if still combed (p/c + n)\n\u2018\npc_u\n\u2019\n2-way matching, and trying 3rd match (same order) if still combed (p/c + u)\n\u2018\npc_n_ub\n\u2019\n2-way matching, trying 3rd match if still combed, and trying 4th/5th matches if\nstill combed (p/c + n + u/b)\n\u2018\npcn\n\u2019\n3-way matching (p/c/n)\n\u2018\npcn_ub\n\u2019\n3-way matching, and trying 4th/5th matches if all 3 of the original matches are\ndetected as combed (p/c/n + u/b)\nThe parenthesis at the end indicate the matches that would be used for that\nmode assuming\norder\n=\ntff\n(and\nfield\non\nauto\nor\ntop\n).\nIn terms of speed\npc\nmode is by far the fastest and\npcn_ub\nis\nthe slowest.\nDefault value is\npc_n\n.\n- **`ppsrc`**\n  - Mark the main input stream as a pre-processed input, and enable the secondary\ninput stream as the clean source to pick the fields from. See the filter\nintroduction for more details. It is similar to the\nclip2\nfeature from\nVFM/TFM.\nDefault value is\n0\n(disabled).\n- **`field`**\n  - Set the field to match from. It is recommended to set this to the same value as\norder\nunless you experience matching failures with that setting. In\ncertain circumstances changing the field that is used to match from can have a\nlarge impact on matching performance. Available values are:\n\u2018\nauto\n\u2019\nAutomatic (same value as\norder\n).\n\u2018\nbottom\n\u2019\nMatch from the bottom field.\n\u2018\ntop\n\u2019\nMatch from the top field.\nDefault value is\nauto\n.\n- **`mchroma`**\n  - Set whether or not chroma is included during the match comparisons. In most\ncases it is recommended to leave this enabled. You should set this to\n0\nonly if your clip has bad chroma problems such as heavy rainbowing or other\nartifacts. Setting this to\n0\ncould also be used to speed things up at\nthe cost of some accuracy.\nDefault value is\n1\n.\n- **`y0`**\n- **`y1`**\n  - These define an exclusion band which excludes the lines between\ny0\nand\ny1\nfrom being included in the field matching decision. An exclusion\nband can be used to ignore subtitles, a logo, or other things that may\ninterfere with the matching.\ny0\nsets the starting scan line and\ny1\nsets the ending line; all lines in between\ny0\nand\ny1\n(including\ny0\nand\ny1\n) will be ignored. Setting\ny0\nand\ny1\nto the same value will disable the feature.\ny0\nand\ny1\ndefaults to\n0\n.\n- **`scthresh`**\n  - Set the scene change detection threshold as a percentage of maximum change on\nthe luma plane. Good values are in the\n[8.0, 14.0]\nrange. Scene change\ndetection is only relevant in case\ncombmatch\n=\nsc\n.  The range for\nscthresh\nis\n[0.0, 100.0]\n.\nDefault value is\n12.0\n.\n- **`combmatch`**\n  - When\ncombatch\nis not\nnone\n,\nfieldmatch\nwill take into\naccount the combed scores of matches when deciding what match to use as the\nfinal match. Available values are:\n\u2018\nnone\n\u2019\nNo final matching based on combed scores.\n\u2018\nsc\n\u2019\nCombed scores are only used when a scene change is detected.\n\u2018\nfull\n\u2019\nUse combed scores all the time.\nDefault is\nsc\n.\n- **`combdbg`**\n  - Force\nfieldmatch\nto calculate the combed metrics for certain matches and\nprint them. This setting is known as\nmicout\nin TFM/VFM vocabulary.\nAvailable values are:\n\u2018\nnone\n\u2019\nNo forced calculation.\n\u2018\npcn\n\u2019\nForce p/c/n calculations.\n\u2018\npcnub\n\u2019\nForce p/c/n/u/b calculations.\nDefault value is\nnone\n.\n- **`cthresh`**\n  - This is the area combing threshold used for combed frame detection. This\nessentially controls how \"strong\" or \"visible\" combing must be to be detected.\nLarger values mean combing must be more visible and smaller values mean combing\ncan be less visible or strong and still be detected. Valid settings are from\n-1\n(every pixel will be detected as combed) to\n255\n(no pixel will\nbe detected as combed). This is basically a pixel difference value. A good\nrange is\n[8, 12]\n.\nDefault value is\n9\n.\n- **`chroma`**\n  - Sets whether or not chroma is considered in the combed frame decision.  Only\ndisable this if your source has chroma problems (rainbowing, etc.) that are\ncausing problems for the combed frame detection with chroma enabled. Actually,\nusing\nchroma\n=\n0\nis usually more reliable, except for the case\nwhere there is chroma only combing in the source.\nDefault value is\n0\n.\n- **`blockx`**\n- **`blocky`**\n  - Respectively set the x-axis and y-axis size of the window used during combed\nframe detection. This has to do with the size of the area in which\ncombpel\npixels are required to be detected as combed for a frame to be\ndeclared combed. See the\ncombpel\nparameter description for more info.\nPossible values are any number that is a power of 2 starting at 4 and going up\nto 512.\nDefault value is\n16\n.\n- **`combpel`**\n  - The number of combed pixels inside any of the\nblocky\nby\nblockx\nsize blocks on the frame for the frame to be detected as\ncombed. While\ncthresh\ncontrols how \"visible\" the combing must be, this\nsetting controls \"how much\" combing there must be in any localized area (a\nwindow defined by the\nblockx\nand\nblocky\nsettings) on the\nframe. Minimum value is\n0\nand maximum is\nblocky x blockx\n(at\nwhich point no frames will ever be detected as combed). This setting is known\nas\nMI\nin TFM/VFM vocabulary.\nDefault value is\n80\n.\nSpecify the assumed field order of the input stream. Available values are:\n\n\n- **`\u2018auto\u2019`**\n  - Auto detect parity (use FFmpeg\u2019s internal parity value).\n- **`\u2018bff\u2019`**\n  - Assume bottom field first.\n- **`\u2018tff\u2019`**\n  - Assume top field first.\nAuto detect parity (use FFmpeg\u2019s internal parity value).\n\n\nAssume bottom field first.\n\n\nAssume top field first.\n\n\nNote that it is sometimes recommended not to trust the parity announced by the\nstream.\n\n\nDefault value is auto.\n\n\nSet the matching mode or strategy to use. pc mode is the safest in the\nsense that it won\u2019t risk creating jerkiness due to duplicate frames when\npossible, but if there are bad edits or blended fields it will end up\noutputting combed frames when a good match might actually exist. On the other\nhand, pcn_ub mode is the most risky in terms of creating jerkiness,\nbut will almost always find a good frame if there is one. The other values are\nall somewhere in between pc and pcn_ub in terms of risking\njerkiness and creating duplicate frames versus finding good matches in sections\nwith bad edits, orphaned fields, blended fields, etc.\n\n\nMore details about p/c/n/u/b are available in p/c/n/u/b meaning section.\n\n\nAvailable values are:\n\n\n- **`\u2018pc\u2019`**\n  - 2-way matching (p/c)\n- **`\u2018pc_n\u2019`**\n  - 2-way matching, and trying 3rd match if still combed (p/c + n)\n- **`\u2018pc_u\u2019`**\n  - 2-way matching, and trying 3rd match (same order) if still combed (p/c + u)\n- **`\u2018pc_n_ub\u2019`**\n  - 2-way matching, trying 3rd match if still combed, and trying 4th/5th matches if\nstill combed (p/c + n + u/b)\n- **`\u2018pcn\u2019`**\n  - 3-way matching (p/c/n)\n- **`\u2018pcn_ub\u2019`**\n  - 3-way matching, and trying 4th/5th matches if all 3 of the original matches are\ndetected as combed (p/c/n + u/b)\n2-way matching (p/c)\n\n\n2-way matching, and trying 3rd match if still combed (p/c + n)\n\n\n2-way matching, and trying 3rd match (same order) if still combed (p/c + u)\n\n\n2-way matching, trying 3rd match if still combed, and trying 4th/5th matches if\nstill combed (p/c + n + u/b)\n\n\n3-way matching (p/c/n)\n\n\n3-way matching, and trying 4th/5th matches if all 3 of the original matches are\ndetected as combed (p/c/n + u/b)\n\n\nThe parenthesis at the end indicate the matches that would be used for that\nmode assuming order=tff (and field on auto or\ntop).\n\n\nIn terms of speed pc mode is by far the fastest and pcn_ub is\nthe slowest.\n\n\nDefault value is pc_n.\n\n\nMark the main input stream as a pre-processed input, and enable the secondary\ninput stream as the clean source to pick the fields from. See the filter\nintroduction for more details. It is similar to the clip2 feature from\nVFM/TFM.\n\n\nDefault value is 0 (disabled).\n\n\nSet the field to match from. It is recommended to set this to the same value as\norder unless you experience matching failures with that setting. In\ncertain circumstances changing the field that is used to match from can have a\nlarge impact on matching performance. Available values are:\n\n\n- **`\u2018auto\u2019`**\n  - Automatic (same value as\norder\n).\n- **`\u2018bottom\u2019`**\n  - Match from the bottom field.\n- **`\u2018top\u2019`**\n  - Match from the top field.\nAutomatic (same value as order).\n\n\nMatch from the bottom field.\n\n\nMatch from the top field.\n\n\nDefault value is auto.\n\n\nSet whether or not chroma is included during the match comparisons. In most\ncases it is recommended to leave this enabled. You should set this to 0\nonly if your clip has bad chroma problems such as heavy rainbowing or other\nartifacts. Setting this to 0 could also be used to speed things up at\nthe cost of some accuracy.\n\n\nDefault value is 1.\n\n\nThese define an exclusion band which excludes the lines between y0 and\ny1 from being included in the field matching decision. An exclusion\nband can be used to ignore subtitles, a logo, or other things that may\ninterfere with the matching. y0 sets the starting scan line and\ny1 sets the ending line; all lines in between y0 and\ny1 (including y0 and y1) will be ignored. Setting\ny0 and y1 to the same value will disable the feature.\ny0 and y1 defaults to 0.\n\n\nSet the scene change detection threshold as a percentage of maximum change on\nthe luma plane. Good values are in the [8.0, 14.0] range. Scene change\ndetection is only relevant in case combmatch=sc.  The range for\nscthresh is [0.0, 100.0].\n\n\nDefault value is 12.0.\n\n\nWhen combatch is not none, fieldmatch will take into\naccount the combed scores of matches when deciding what match to use as the\nfinal match. Available values are:\n\n\n- **`\u2018none\u2019`**\n  - No final matching based on combed scores.\n- **`\u2018sc\u2019`**\n  - Combed scores are only used when a scene change is detected.\n- **`\u2018full\u2019`**\n  - Use combed scores all the time.\nNo final matching based on combed scores.\n\n\nCombed scores are only used when a scene change is detected.\n\n\nUse combed scores all the time.\n\n\nDefault is sc.\n\n\nForce fieldmatch to calculate the combed metrics for certain matches and\nprint them. This setting is known as micout in TFM/VFM vocabulary.\nAvailable values are:\n\n\n- **`\u2018none\u2019`**\n  - No forced calculation.\n- **`\u2018pcn\u2019`**\n  - Force p/c/n calculations.\n- **`\u2018pcnub\u2019`**\n  - Force p/c/n/u/b calculations.\nNo forced calculation.\n\n\nForce p/c/n calculations.\n\n\nForce p/c/n/u/b calculations.\n\n\nDefault value is none.\n\n\nThis is the area combing threshold used for combed frame detection. This\nessentially controls how \"strong\" or \"visible\" combing must be to be detected.\nLarger values mean combing must be more visible and smaller values mean combing\ncan be less visible or strong and still be detected. Valid settings are from\n-1 (every pixel will be detected as combed) to 255 (no pixel will\nbe detected as combed). This is basically a pixel difference value. A good\nrange is [8, 12].\n\n\nDefault value is 9.\n\n\nSets whether or not chroma is considered in the combed frame decision.  Only\ndisable this if your source has chroma problems (rainbowing, etc.) that are\ncausing problems for the combed frame detection with chroma enabled. Actually,\nusing chroma=0 is usually more reliable, except for the case\nwhere there is chroma only combing in the source.\n\n\nDefault value is 0.\n\n\nRespectively set the x-axis and y-axis size of the window used during combed\nframe detection. This has to do with the size of the area in which\ncombpel pixels are required to be detected as combed for a frame to be\ndeclared combed. See the combpel parameter description for more info.\nPossible values are any number that is a power of 2 starting at 4 and going up\nto 512.\n\n\nDefault value is 16.\n\n\nThe number of combed pixels inside any of the blocky by\nblockx size blocks on the frame for the frame to be detected as\ncombed. While cthresh controls how \"visible\" the combing must be, this\nsetting controls \"how much\" combing there must be in any localized area (a\nwindow defined by the blockx and blocky settings) on the\nframe. Minimum value is 0 and maximum is blocky x blockx (at\nwhich point no frames will ever be detected as combed). This setting is known\nas MI in TFM/VFM vocabulary.\n\n\nDefault value is 80.\n\n\n",
  "filter_type": "vf",
  "formula_input_typings": "[StreamType.video] + [StreamType.video] if ppsrc else []",
  "formula_output_typings": null,
  "id": "ff_vf_fieldmatch",
  "input_stream_typings": [],
  "is_input_dynamic": true,
  "is_output_dynamic": false,
  "name": "fieldmatch",
  "options": [
    {
      "alias": [
        "order"
      ],
      "choices": [
        {
          "help": "auto detect parity",
          "name": "auto",
          "value": "FM_PARITY_AUTO"
        },
        {
          "help": "assume bottom field first",
          "name": "bff",
          "value": "FM_PARITY_BOTTOM"
        },
        {
          "help": "assume top field first",
          "name": "tff",
          "value": "FM_PARITY_TOP"
        }
      ],
      "default": "FM_PARITY_AUTO",
      "description": "<dd><p>Specify the assumed field order of the input stream. Available values are:\n</p>\n<dl compact=\"compact\">\n<dt>\u2018<samp>auto</samp>\u2019</dt>\n<dd><p>Auto detect parity (use FFmpeg\u2019s internal parity value).\n</p></dd>\n<dt>\u2018<samp>bff</samp>\u2019</dt>\n<dd><p>Assume bottom field first.\n</p></dd>\n<dt>\u2018<samp>tff</samp>\u2019</dt>\n<dd><p>Assume top field first.\n</p></dd>\n</dl>\n<p>Note that it is sometimes recommended not to trust the parity announced by the\nstream.\n</p>\n<p>Default value is <var>auto</var>.\n</p>\n</dd>",
      "name": "order",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "mode"
      ],
      "choices": [
        {
          "help": "2-way match (p/c)",
          "name": "pc",
          "value": "MODE_PC"
        },
        {
          "help": "2-way match + 3rd match on combed (p/c + u)",
          "name": "pc_n",
          "value": "MODE_PC_N"
        },
        {
          "help": "2-way match + 3rd match (same order) on combed (p/c + u)",
          "name": "pc_u",
          "value": "MODE_PC_U"
        },
        {
          "help": "2-way match + 3rd match on combed + 4th/5th matches if still combed (p/c + u + u/b)",
          "name": "pc_n_ub",
          "value": "MODE_PC_N_UB"
        },
        {
          "help": "3-way match (p/c/n)",
          "name": "pcn",
          "value": "MODE_PCN"
        },
        {
          "help": "3-way match + 4th/5th matches on combed (p/c/n + u/b)",
          "name": "pcn_ub",
          "value": "MODE_PCN_UB"
        }
      ],
      "default": "MODE_PC_N",
      "description": "<dd><p>Set the matching mode or strategy to use. <samp>pc</samp> mode is the safest in the\nsense that it won\u2019t risk creating jerkiness due to duplicate frames when\npossible, but if there are bad edits or blended fields it will end up\noutputting combed frames when a good match might actually exist. On the other\nhand, <samp>pcn_ub</samp> mode is the most risky in terms of creating jerkiness,\nbut will almost always find a good frame if there is one. The other values are\nall somewhere in between <samp>pc</samp> and <samp>pcn_ub</samp> in terms of risking\njerkiness and creating duplicate frames versus finding good matches in sections\nwith bad edits, orphaned fields, blended fields, etc.\n</p>\n<p>More details about p/c/n/u/b are available in <a href=\"#p_002fc_002fn_002fu_002fb-meaning\">p/c/n/u/b meaning</a> section.\n</p>\n<p>Available values are:\n</p>\n<dl compact=\"compact\">\n<dt>\u2018<samp>pc</samp>\u2019</dt>\n<dd><p>2-way matching (p/c)\n</p></dd>\n<dt>\u2018<samp>pc_n</samp>\u2019</dt>\n<dd><p>2-way matching, and trying 3rd match if still combed (p/c + n)\n</p></dd>\n<dt>\u2018<samp>pc_u</samp>\u2019</dt>\n<dd><p>2-way matching, and trying 3rd match (same order) if still combed (p/c + u)\n</p></dd>\n<dt>\u2018<samp>pc_n_ub</samp>\u2019</dt>\n<dd><p>2-way matching, trying 3rd match if still combed, and trying 4th/5th matches if\nstill combed (p/c + n + u/b)\n</p></dd>\n<dt>\u2018<samp>pcn</samp>\u2019</dt>\n<dd><p>3-way matching (p/c/n)\n</p></dd>\n<dt>\u2018<samp>pcn_ub</samp>\u2019</dt>\n<dd><p>3-way matching, and trying 4th/5th matches if all 3 of the original matches are\ndetected as combed (p/c/n + u/b)\n</p></dd>\n</dl>\n<p>The parenthesis at the end indicate the matches that would be used for that\nmode assuming <samp>order</samp>=<var>tff</var> (and <samp>field</samp> on <var>auto</var> or\n<var>top</var>).\n</p>\n<p>In terms of speed <samp>pc</samp> mode is by far the fastest and <samp>pcn_ub</samp> is\nthe slowest.\n</p>\n<p>Default value is <var>pc_n</var>.\n</p>\n</dd>",
      "name": "mode",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "ppsrc"
      ],
      "choices": [],
      "default": 0,
      "description": "<dd><p>Mark the main input stream as a pre-processed input, and enable the secondary\ninput stream as the clean source to pick the fields from. See the filter\nintroduction for more details. It is similar to the <samp>clip2</samp> feature from\nVFM/TFM.\n</p>\n<p>Default value is <code>0</code> (disabled).\n</p>\n</dd>",
      "name": "ppsrc",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [
        "field"
      ],
      "choices": [
        {
          "help": "automatic (same value as 'order')",
          "name": "auto",
          "value": "FM_PARITY_AUTO"
        },
        {
          "help": "bottom field",
          "name": "bottom",
          "value": "FM_PARITY_BOTTOM"
        },
        {
          "help": "top field",
          "name": "top",
          "value": "FM_PARITY_TOP"
        }
      ],
      "default": "FM_PARITY_AUTO",
      "description": "<dd><p>Set the field to match from. It is recommended to set this to the same value as\n<samp>order</samp> unless you experience matching failures with that setting. In\ncertain circumstances changing the field that is used to match from can have a\nlarge impact on matching performance. Available values are:\n</p>\n<dl compact=\"compact\">\n<dt>\u2018<samp>auto</samp>\u2019</dt>\n<dd><p>Automatic (same value as <samp>order</samp>).\n</p></dd>\n<dt>\u2018<samp>bottom</samp>\u2019</dt>\n<dd><p>Match from the bottom field.\n</p></dd>\n<dt>\u2018<samp>top</samp>\u2019</dt>\n<dd><p>Match from the top field.\n</p></dd>\n</dl>\n<p>Default value is <var>auto</var>.\n</p>\n</dd>",
      "name": "field",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "mchroma"
      ],
      "choices": [],
      "default": 1,
      "description": "<dd><p>Set whether or not chroma is included during the match comparisons. In most\ncases it is recommended to leave this enabled. You should set this to <code>0</code>\nonly if your clip has bad chroma problems such as heavy rainbowing or other\nartifacts. Setting this to <code>0</code> could also be used to speed things up at\nthe cost of some accuracy.\n</p>\n<p>Default value is <code>1</code>.\n</p>\n</dd>",
      "name": "mchroma",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [
        "y0"
      ],
      "choices": [],
      "default": 0,
      "description": "<dd><p>These define an exclusion band which excludes the lines between <samp>y0</samp> and\n<samp>y1</samp> from being included in the field matching decision. An exclusion\nband can be used to ignore subtitles, a logo, or other things that may\ninterfere with the matching. <samp>y0</samp> sets the starting scan line and\n<samp>y1</samp> sets the ending line; all lines in between <samp>y0</samp> and\n<samp>y1</samp> (including <samp>y0</samp> and <samp>y1</samp>) will be ignored. Setting\n<samp>y0</samp> and <samp>y1</samp> to the same value will disable the feature.\n<samp>y0</samp> and <samp>y1</samp> defaults to <code>0</code>.\n</p>\n</dd>",
      "name": "y0",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "y1"
      ],
      "choices": [],
      "default": 0,
      "description": "<dd><p>These define an exclusion band which excludes the lines between <samp>y0</samp> and\n<samp>y1</samp> from being included in the field matching decision. An exclusion\nband can be used to ignore subtitles, a logo, or other things that may\ninterfere with the matching. <samp>y0</samp> sets the starting scan line and\n<samp>y1</samp> sets the ending line; all lines in between <samp>y0</samp> and\n<samp>y1</samp> (including <samp>y0</samp> and <samp>y1</samp>) will be ignored. Setting\n<samp>y0</samp> and <samp>y1</samp> to the same value will disable the feature.\n<samp>y0</samp> and <samp>y1</samp> defaults to <code>0</code>.\n</p>\n</dd>",
      "name": "y1",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "scthresh"
      ],
      "choices": [],
      "default": 12.0,
      "description": "<dd><p>Set the scene change detection threshold as a percentage of maximum change on\nthe luma plane. Good values are in the <code>[8.0, 14.0]</code> range. Scene change\ndetection is only relevant in case <samp>combmatch</samp>=<var>sc</var>.  The range for\n<samp>scthresh</samp> is <code>[0.0, 100.0]</code>.\n</p>\n<p>Default value is <code>12.0</code>.\n</p>\n</dd>",
      "name": "scthresh",
      "required": false,
      "typing": "float"
    },
    {
      "alias": [
        "combmatch"
      ],
      "choices": [
        {
          "help": "disable combmatching",
          "name": "none",
          "value": "COMBMATCH_NONE"
        },
        {
          "help": "enable combmatching only on scene change",
          "name": "sc",
          "value": "COMBMATCH_SC"
        },
        {
          "help": "enable combmatching all the time",
          "name": "full",
          "value": "COMBMATCH_FULL"
        }
      ],
      "default": "COMBMATCH_SC",
      "description": "<dd><p>When <samp>combatch</samp> is not <var>none</var>, <code>fieldmatch</code> will take into\naccount the combed scores of matches when deciding what match to use as the\nfinal match. Available values are:\n</p>\n<dl compact=\"compact\">\n<dt>\u2018<samp>none</samp>\u2019</dt>\n<dd><p>No final matching based on combed scores.\n</p></dd>\n<dt>\u2018<samp>sc</samp>\u2019</dt>\n<dd><p>Combed scores are only used when a scene change is detected.\n</p></dd>\n<dt>\u2018<samp>full</samp>\u2019</dt>\n<dd><p>Use combed scores all the time.\n</p></dd>\n</dl>\n<p>Default is <var>sc</var>.\n</p>\n</dd>",
      "name": "combmatch",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "combdbg"
      ],
      "choices": [
        {
          "help": "no forced calculation",
          "name": "none",
          "value": "COMBDBG_NONE"
        },
        {
          "help": "calculate p/c/n",
          "name": "pcn",
          "value": "COMBDBG_PCN"
        },
        {
          "help": "calculate p/c/n/u/b",
          "name": "pcnub",
          "value": "COMBDBG_PCNUB"
        }
      ],
      "default": "COMBDBG_NONE",
      "description": "<dd><p>Force <code>fieldmatch</code> to calculate the combed metrics for certain matches and\nprint them. This setting is known as <samp>micout</samp> in TFM/VFM vocabulary.\nAvailable values are:\n</p>\n<dl compact=\"compact\">\n<dt>\u2018<samp>none</samp>\u2019</dt>\n<dd><p>No forced calculation.\n</p></dd>\n<dt>\u2018<samp>pcn</samp>\u2019</dt>\n<dd><p>Force p/c/n calculations.\n</p></dd>\n<dt>\u2018<samp>pcnub</samp>\u2019</dt>\n<dd><p>Force p/c/n/u/b calculations.\n</p></dd>\n</dl>\n<p>Default value is <var>none</var>.\n</p>\n</dd>",
      "name": "combdbg",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "cthresh"
      ],
      "choices": [],
      "default": 9,
      "description": "<dd><p>This is the area combing threshold used for combed frame detection. This\nessentially controls how \"strong\" or \"visible\" combing must be to be detected.\nLarger values mean combing must be more visible and smaller values mean combing\ncan be less visible or strong and still be detected. Valid settings are from\n<code>-1</code> (every pixel will be detected as combed) to <code>255</code> (no pixel will\nbe detected as combed). This is basically a pixel difference value. A good\nrange is <code>[8, 12]</code>.\n</p>\n<p>Default value is <code>9</code>.\n</p>\n</dd>",
      "name": "cthresh",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "chroma"
      ],
      "choices": [],
      "default": 0,
      "description": "<dd><p>Sets whether or not chroma is considered in the combed frame decision.  Only\ndisable this if your source has chroma problems (rainbowing, etc.) that are\ncausing problems for the combed frame detection with chroma enabled. Actually,\nusing <samp>chroma</samp>=<var>0</var> is usually more reliable, except for the case\nwhere there is chroma only combing in the source.\n</p>\n<p>Default value is <code>0</code>.\n</p>\n</dd>",
      "name": "chroma",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [
        "blockx"
      ],
      "choices": [],
      "default": 16,
      "description": "<dd><p>Respectively set the x-axis and y-axis size of the window used during combed\nframe detection. This has to do with the size of the area in which\n<samp>combpel</samp> pixels are required to be detected as combed for a frame to be\ndeclared combed. See the <samp>combpel</samp> parameter description for more info.\nPossible values are any number that is a power of 2 starting at 4 and going up\nto 512.\n</p>\n<p>Default value is <code>16</code>.\n</p>\n</dd>",
      "name": "blockx",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "blocky"
      ],
      "choices": [],
      "default": 16,
      "description": "<dd><p>Respectively set the x-axis and y-axis size of the window used during combed\nframe detection. This has to do with the size of the area in which\n<samp>combpel</samp> pixels are required to be detected as combed for a frame to be\ndeclared combed. See the <samp>combpel</samp> parameter description for more info.\nPossible values are any number that is a power of 2 starting at 4 and going up\nto 512.\n</p>\n<p>Default value is <code>16</code>.\n</p>\n</dd>",
      "name": "blocky",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "combpel"
      ],
      "choices": [],
      "default": 80,
      "description": "<dd><p>The number of combed pixels inside any of the <samp>blocky</samp> by\n<samp>blockx</samp> size blocks on the frame for the frame to be detected as\ncombed. While <samp>cthresh</samp> controls how \"visible\" the combing must be, this\nsetting controls \"how much\" combing there must be in any localized area (a\nwindow defined by the <samp>blockx</samp> and <samp>blocky</samp> settings) on the\nframe. Minimum value is <code>0</code> and maximum is <code>blocky x blockx</code> (at\nwhich point no frames will ever be detected as combed). This setting is known\nas <samp>MI</samp> in TFM/VFM vocabulary.\n</p>\n<p>Default value is <code>80</code>.\n</p></dd>",
      "name": "combpel",
      "required": false,
      "typing": "int"
    }
  ],
  "output_stream_typings": [
    {
      "name": "default",
      "type": "AVMEDIA_TYPE_VIDEO"
    }
  ],
  "ref": "https://ffmpeg.org/ffmpeg-filters.html#fieldmatch"
}
