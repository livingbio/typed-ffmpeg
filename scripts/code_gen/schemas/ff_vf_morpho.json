{
  "description": "### 11.169 morpho\n\nThis filter allows to apply main morphological grayscale transforms, erode and\ndilate with arbitrary structures set in second input stream.\n\nUnlike naive implementation and much slower performance in erosion and\ndilation filters, when speed is critical `morpho` filter should be used\ninstead.\n\nA description of accepted options follows,\n\n**mode**\n\n    Set morphological transform to apply, can be: \u2018erode\u2019 \u2018dilate\u2019 \u2018open\u2019 \u2018close\u2019 \u2018gradient\u2019 \u2018tophat\u2019 \u2018blackhat\u2019 Default is erode. \n\n**planes**\n\n    Set planes to filter, by default all planes except alpha are filtered. \n\n**structure**\n\n    Set which structure video frames will be processed from second input stream, can be first or all. Default is all. \n\nThe `morpho` filter also supports the framesync options.\n\n",
  "filter_type": "vf",
  "formula_input_typings": null,
  "formula_output_typings": null,
  "id": "ff_vf_morpho",
  "input_stream_typings": [
    {
      "name": "default",
      "type": "AVMEDIA_TYPE_VIDEO"
    },
    {
      "name": "structure",
      "type": "AVMEDIA_TYPE_VIDEO"
    }
  ],
  "is_input_dynamic": false,
  "is_output_dynamic": false,
  "is_support_framesync": true,
  "is_support_timeline": true,
  "name": "morpho",
  "options": [
    {
      "alias": [
        "mode"
      ],
      "choices": [
        {
          "help": "((void*)0)",
          "name": "erode",
          "value": "ERODE"
        },
        {
          "help": "((void*)0)",
          "name": "dilate",
          "value": "DILATE"
        },
        {
          "help": "((void*)0)",
          "name": "open",
          "value": "OPEN"
        },
        {
          "help": "((void*)0)",
          "name": "close",
          "value": "CLOSE"
        },
        {
          "help": "((void*)0)",
          "name": "gradient",
          "value": "GRADIENT"
        },
        {
          "help": "((void*)0)",
          "name": "tophat",
          "value": "TOPHAT"
        },
        {
          "help": "((void*)0)",
          "name": "blackhat",
          "value": "BLACKHAT"
        }
      ],
      "default": 0,
      "description": "<dd><p>Set morphological transform to apply, can be:\n</p>\n<dl compact=\"compact\">\n<dt>\u2018<samp>erode</samp>\u2019</dt>\n<dt>\u2018<samp>dilate</samp>\u2019</dt>\n<dt>\u2018<samp>open</samp>\u2019</dt>\n<dt>\u2018<samp>close</samp>\u2019</dt>\n<dt>\u2018<samp>gradient</samp>\u2019</dt>\n<dt>\u2018<samp>tophat</samp>\u2019</dt>\n<dt>\u2018<samp>blackhat</samp>\u2019</dt>\n</dl>\n<p>Default is <code>erode</code>.\n</p>\n</dd>",
      "name": "mode",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "planes"
      ],
      "choices": [],
      "default": 7,
      "description": "<dd><p>Set planes to filter, by default all planes except alpha are filtered.\n</p>\n</dd>",
      "name": "planes",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [
        "structure"
      ],
      "choices": [
        {
          "help": "process only first structure, ignore rest",
          "name": "first",
          "value": 0
        },
        {
          "help": "process all structure",
          "name": "all",
          "value": 1
        }
      ],
      "default": 1,
      "description": "<dd><p>Set which structure video frames will be processed from second input stream,\ncan be <var>first</var> or <var>all</var>. Default is <var>all</var>.\n</p></dd>",
      "name": "structure",
      "required": false,
      "typing": "int"
    },
    {
      "alias": [],
      "choices": [],
      "default": null,
      "description": "timeline editing",
      "name": "enable",
      "required": false,
      "typing": "str"
    },
    {
      "alias": [],
      "choices": [
        {
          "help": "Repeat the last frame.",
          "name": "repeat",
          "value": "repeat"
        },
        {
          "help": "End both streams.",
          "name": "endall",
          "value": "endall"
        },
        {
          "help": "Pass the main input through.",
          "name": "pass",
          "value": "pass"
        }
      ],
      "default": "repeat",
      "description": "The action to take when EOF is encountered on the secondary input; it accepts one of the following values",
      "name": "eof_action",
      "required": false,
      "typing": "str"
    },
    {
      "alias": [],
      "choices": [],
      "default": 0,
      "description": "Force the output to terminate when the shortest input terminates.",
      "name": "shortest",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [],
      "choices": [],
      "default": 1,
      "description": "force the filter to extend the last frame of secondary streams until the end of the primary stream.",
      "name": "repeatlast",
      "required": false,
      "typing": "bool"
    },
    {
      "alias": [],
      "choices": [
        {
          "help": "Frame from secondary input with the nearest lower or equal timestamp to the primary input frame.",
          "name": "default",
          "value": "default"
        },
        {
          "help": "Frame from secondary input with the absolute nearest timestamp to the primary input frame.",
          "name": "nearest",
          "value": "nearest"
        }
      ],
      "default": "default",
      "description": "How strictly to sync streams based on secondary input timestamps; it accepts one of the following values:",
      "name": "ts_sync_mode",
      "required": false,
      "typing": "str"
    }
  ],
  "output_stream_typings": [
    {
      "name": "default",
      "type": "AVMEDIA_TYPE_VIDEO"
    }
  ],
  "ref": "https://ffmpeg.org/ffmpeg-filters.html#morpho"
}
